---
title: 语言C++
date: 2023-10-30 00:00:00
updated: 2023-10-30 00:00:00
description: C++经久不衰，仍然是一门很底层且基础的语言，了解C++等于了解了不少计算机底层;这是一篇面向已有经验并为了快速复习的文章
categories:
- 知识
- 语言
- 通用语言
- C++
tags:
- C++
aside: true
top_img: img/a1.png
cover: img/a1.png
---

# 语言C++

## C++基础

完全的接近C的基础，建议跳过不看。

### C++ 标识符

一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）

### C++数据类型

#### 七种基本数据类型：

| 类型                        | 关键字  |
| :-------------------------- | :------ |
| 布尔型                      | bool    |
| 字符型                      | char    |
| 整型                        | int     |
| 浮点型                      | float   |
| 双浮点型                    | double  |
| 无类型                      | void    |
| 宽字符型（等价于short int） | wchar_t |

#### 常用内置类型：

| 类型               | 位            | 范围                                                         |
| :----------------- | :------------ | :----------------------------------------------------------- |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767                                              |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

####  typedef声明

使用**typedef** 为一个已有的类型取一个新的名字

  ```c++
typedef type newname; 
  ```

####  枚举类型

枚举是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内

  ```c++
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
//枚举类型对应一个整数，默认从0开始依次赋值，也可以手动指定
  ```

####  类型转换

* 静态转换

  ```c++
//不进行任何运行时类型检查，因此可能会导致运行时错误
int i = 10;
float f = static_cast<float>(i); // 静态将int类型转换为float类型
  ```

* 动态转换

  ```c++
//运行时进行类型检查，如果不能进行转换则返回空指针或引发异常
class Base {};
class Derived : public Base {};
Base* ptr_base = new Derived;
Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
  ```

* 常量转换

  ```c++
//只能用于转换掉 const 属性，不能改变对象的类型
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
  ```

* 重新解释

  ```c++
  //将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换,不进行任何类型检查
  int i = 10;
  float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
  ```

### C++变量

####  变量类型

1. 整数类型（Integer Types）：
   - int：用于表示整数，通常占用4个字节。
   - short：用于表示短整数，通常占用2个字节。
   -  long ：用于表示长整数，通常占用4个字节。
   -  long long ：用于表示更长的整数，通常占用8个字节。
2. 浮点类型（Floating-Point Types）：
   -  float ：用于表示单精度浮点数，通常占用4个字节。
   -  double ：用于表示双精度浮点数，通常占用8个字节。
   -  long double ：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
3. 字符类型（Character Types）：
   -  char ：用于表示字符，通常占用1个字节。
   -  wchar_t ：用于表示宽字符，通常占用2或4个字节。
   -  char16_t ：用于表示16位Unicode字符，占用2个字节。
   -  char32_t ：用于表示32位Unicode字符，占用4个字节。
4. 布尔类型（Boolean Type）：
   -  bool ：用于表示布尔值，只能取 true 或 false 。
5. 枚举类型（Enumeration Types）：
   -  enum ：用于定义一组命名的整数常量。
6. 指针类型（Pointer Types）：
   -  type* ：用于表示指向类型为 type 的对象的指针。
7. 数组类型（Array Types）：
   -  type[] 或 type[size] ：用于表示具有相同类型的元素组成的数组。
8. 结构体类型（Structure Types）：
   -  struct ：用于定义包含多个不同类型成员的结构。
9. 类类型（Class Types）：
   -  class ：用于定义具有属性和方法的自定义类型。
10. 共用体类型（Union Types）：
    -  union ：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。

####  变量修饰符

下面列出了数据类型修饰符：

- signed：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。
- unsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。
- short：表示变量的范围比 int 更小。short int 可以缩写为 short。
- long：表示变量的范围比 int 更大。long int 可以缩写为 long。
- long long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。
- float：表示单精度浮点数。
- double：表示双精度浮点数。
- bool：表示布尔类型，只有 true 和 false 两个值。
- char：表示字符类型。
- wchar_t：表示宽字符类型，可以存储 Unicode 字符。

​	修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。这些修饰符也可以组合使用，修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。C++ 允许使用速记符号来声明**无符号短整数**或**无符号长整数**。可以不写 int，只写单词 **unsigned、short** 或 **long**，**int** 是隐含的。

#### 类型限定符

类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。

| 限定符   | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 定义常量，表示该变量的值不能被修改。。             |
| volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。 |
| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |
| mutable  | 表示类中的成员变量可以在 const 成员函数中被修改。            |
| static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
| register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。 |

####  存储类型

* auto 存储类

​	自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。根据初始化表达式自动推断被声明的变量的类型，必须是初始化为同一类型

* register 存储类

​	register存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

* static 存储类

​	static存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。在C++中,当static用在类数据成员上时,会导致仅有一个该成员的副本被类的所有对象共享。

* extern 存储类

​	extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

* mutable 存储类

​	mutable说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。

* thread_local 存储类

​	使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

####  变量声明

​	变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。当使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。可以使用 **extern** 关键字在任何地方声明一个变量。虽然可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。

```c++
#include <iostream>
using namespace std;
// 变量声明
extern int a, b;
extern int c;
extern float f;
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;

  return 0;
}
```

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

####  变量作用域

一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

作用域是程序的一个区域，变量的作用域可以分为以下几种：

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

### C++结构体

struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```c++
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
```

​	type_name是结构体类型的名称，member_type1 member_name1是标准的变量定义，比如 int i; 或者 float f;或者其他有效的变量定义。为了访问结构的成员，我们使用成员访问运算符（.）

### C++数组

数组本质是连续的内存，数组名即开始的内存地址。

####  数组声明

声明一个数组，需要指定元素的类型和元素的数量

```c++
type arrayName [ arraySize ];
```

####  数组初始化

如下例子：

```c++
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; //自行创建长度的数组
```

####  字符串

字符串是char类型的数组，字符串以'\0'结束

在C++中提供了string类型，以下为常用函数：

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: string str1 = "runoob"; string str2 = "google"; string str = str1 + str2; |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

### C++常量

*常量的值在定义后不能进行修改*。

####  整数常量

```c++
//前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制
//后缀指定长度：后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）
85         // 十进制
0213       // 八进制 
0x4b       // 十六进制 
30         // 整数 
30u        // 无符号整数 
30l        // 长整数 
30ul       // 无符号长整数
```

####  浮点常量

```c++
//指数形式表示时， 必须包含小数点、指数，或同时包含两者;带符号的指数是用 e 或 E 引入的
3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```

####  布尔常量

```c++
true //值代表真。
false //值代表假。
```

####  字符常量

在单引号中的字符量，以下为转义字符

```c++
转义序列	含义
\\	\ 字符
\'	' 字符
\"	" 字符
\?	? 字符
\a	警报铃声
\b	退格键
\f	换页符
\n	换行符
\r	回车
\t	水平制表符
\v	垂直制表符
\ooo	一到三位的八进制数
\xhh . . .	一个或多个数字的十六进制数
```

####  字符串常量

在双引号 **""** 中的字符串

####  定义常量

* 使用#define预处理器

```c++
#define identifier value
```

* 使用 const 关键字

### C++指针与引用

指针一言以蔽之就是存储地址的变量，引用一言以蔽之就是别名。

指针变量声明的一般形式为：

```c++
type *var-name;
```

指针变量使用的一般形式为：

```c++
*var-name
```

引用的创建方法:

```c++
type i;
type& r=i;
//创建了一个对i的引用r，可以认为r=*(&i)
```

### C++运算符

以下类型的运算符：

- 算术运算符、

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                             | 实例             |
| :----- | :------------------------------- | :--------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30  |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *      | 把两个操作数相乘                 | A * B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2   |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0   |
| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11    |
| --     | 自减运算符，整数值减少 1         | A-- 将得到 9     |

- 关系运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

- 逻辑运算符

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

- 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

- 赋值运算符

下表列出了 C++ 支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

- 杂项运算符

下表列出了 C++ 支持的其他一些重要的运算符。

| 运算符               | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| sizeof               | [sizeof 运算符]返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
| Condition ? X : Y    | [条件运算符]。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |
| ,                    | [逗号运算符]会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
| .（点）和 ->（箭头） | [成员运算符]用于引用类、结构和共用体的成员。 |
| Cast                 | [强制转换运算符]把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
| &                    | [指针运算符 &] 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
| *                    | [指针运算符 *] 指向一个变量。例如，*var; 将指向变量 var。 |

### C++控制流

####  循环

* while循环

```c++
while(condition)
{
   statement(s);
}
```

* for循环

```c++
for ( init; condition; increment )
{
   statement(s);
}
```

* do...while循环

```c++
do
{
   statement(s);

}while( condition );
```

* 控制语句
  * break
  * continue
  * goto

####  选择分支

* if...else...

```c++
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
else
{
   // 如果布尔表达式为假将执行的语句
}
```

* switch

```c++
switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
  
    // 可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```

* 三目运算符

```c++
Exp1 ? Exp2 : Exp3; //若exp1为真则返回exp2，否则为exp3
```

### C++函数

*函数是一组一起执行一个任务的语句。*

####  函数定义

定义的一般形式如下

```c++
return_type function_name( parameter list )
{
   body of the function
}
```

函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

####  函数声明

声明包括以下几个部分：

```
return_type function_name( parameter list );
```

####  函数调用

​	当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有三种向函数传递参数的方式：

| 调用类型   | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| [传值调用] | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用] | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| [引用调用] | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

####  Lambda 函数与表达式

​	C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:

```c++
[capture](parameters)->return-type{body}
//C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
//对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：
[this]() { this->someFunc(); }();
```



## C+面向对象

### 类

类是一类事物的模板定义，它的实例化是对象。对象有它自己的静态描述——属性和动态描述——方法。

#### 类

```c++
class classname
{
    Access specifiers:
    	Type members/variables;
    	Member functions(){}
}
//说明：
//1.类的成员方法可以在类内定义，也可以在类内声明而类的外部使用范围解析运算符::定义该函数，如：
class classname
{
    Access specifiers:
    	Type members/variables;
    	Member functions(){}
}
type classname::functions()
{
    return;
}
//2.Access specifiers是类访问修饰符，有public/protected/private
//public可以被任何人访问，protected可以被派生类、友元和自己访问，private只允许友元和自己访问
//3.构造函数和析构函数
//构造函数用于实例化对象时的初始化步骤,若不提供构造函数，编译器会自己使用默认构造
//析构函数用于销毁对象时的收尾步骤
class classname
{
    Access specifiers:
    	Type members/variables;
    	Member functions(){}
    	classname(){}
    	~classname(){}
}
//4.友元 使用关键字friend 友元具有特权，可以访问该类的私有成员，即使它不是该类的成员。友元的作用是允许外部函数或类访问另一个类的私有成员，以便在某些情况下实现更灵活的操作。友元的一个常见用途是允许全局或其他类的成员函数访问私有成员，从而提供更高级的操作或实现特定功能，而无需创建对象。
//5.内联函数 内联函数inline：引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：1.在内联函数内不允许使用循环语句和开关语句；2.内联函数的定义必须出现在内联函数第一次调用之前；3.类结构中所在的类说明内部定义的函数是内联函数。
```

####  实例化对象

```c++
classname instance;
instance.members;
instance.functions();
//6.this指针 当我们调用成员函数时，实际上是替某个对象调用它。成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化 this。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为 this 所指的正是这个对象。任何对类成员的直接访问都被看作是对 this 的隐式引用。对于我们来说，this 形参是隐式定义的。实际上，任何自定义名为 this 的参数或变量的行为都是非法的。我们可以在成员函数体内部使用 this，尽管没有必要，因为 this 的目的总是指向“这个”对象，所以this 是一个常量指针
```

### 继承

​	继承是指完全使用某个类的同时再额外添加部分内容。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。

**基类 & 派生类**

​	一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

```c++
class derived-class: access-specifier base-class
    
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
	<派生类类体>
};
```

​	其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

​	派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。根据访问权限总结出不同的访问类型，如下所示：

| 访问     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但不继承以下：

1. **基类的构造函数、析构函数和拷贝构造函数**：
   - 派生类默认情况下不会继承基类的构造函数、析构函数和拷贝构造函数。如果不显式定义派生类的构造函数，编译器会生成一个默认构造函数，但这个默认构造函数不会自动调用基类的构造函数，而是会尝试调用基类的默认构造函数（如果存在）。
   - 如果在派生类中显式定义构造函数，并且希望调用基类的特定构造函数，需要在派生类的构造函数初始化列表中显式调用基类的构造函数，就像之前的示例中所演示的那样。
2. **基类的重载运算符**：
   - 派生类默认情况下不会继承基类的重载运算符。如果希望在派生类中使用基类的重载运算符，需要自己在派生类中重新定义该运算符。
3. **基类的友元函数**：
   - 派生类不会继承基类的友元函数。友元函数是基于类的友元关系而不是继承关系，因此派生类不会自动继承基类的友元函数。派生类可以自己定义自己的友元函数，但不会继承基类的友元函数。

### 多态

​	允许不同的对象以一致的方式响应相同的消息或调用相同的方法，但实际上执行的操作可以根据对象的实际类型而变化。多态性有助于提高代码的可扩展性和可维护性，同时也提高了代码的灵活性和可复用性。

1. **编译时多态性（静态多态性）**：
   - 也称为早期绑定（early binding）或静态绑定（static binding）。
   - 在编译时已经确定了调用哪个函数或方法。这是因为编译器可以根据变量的静态类型（声明时的类型）来确定调用的函数或方法。
   - C++中的函数重载就是一种编译时多态的例子。
2. **运行时多态性（动态多态性）**：
   - 也称为晚期绑定（late binding）或动态绑定（dynamic binding）。
   - 在运行时根据对象的实际类型来确定调用哪个函数或方法。这是通过虚函数（virtual functions）和基类指针或引用来实现的。
   - C++中使用虚函数来实现运行时多态性。当一个函数在基类中声明为虚函数，并且在派生类中被重写时，通过基类指针或引用调用该函数时，将根据对象的实际类型来调用适当的函数。

```c++
#include <iostream>

class Animal {
public:
    // 声明虚函数
    virtual void Speak() {
        std::cout << "This is an animal." << std::endl;
    }
};

class Dog : public Animal {
public:
    void Speak() override {
        std::cout << "Dog barks" << std::endl;
    }
};

class Cat : public Animal {
public:
    void Speak() override {
        std::cout << "Cat meows" << std::endl;
    }
};

int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->Speak(); // 动态调用 Dog 类的 Speak 方法
    animal2->Speak(); // 动态调用 Cat 类的 Speak 方法

    delete animal1;
    delete animal2;

    return 0;
}
//在上述示例中，Animal 类有一个虚函数 Speak，并且有两个派生类 Dog 和 Cat，它们都重写了 Speak 函数。在 main 函数中，我们创建了两个指向 Animal 类型的指针，分别指向 Dog 类型和 Cat 类型的对象。当调用 Speak 方法时，实际上会根据指针指向的对象的实际类型来调用适当的函数，这就是动态多态性的体现。

//在运行时，animal1 指针指向 Dog 对象，因此调用 Speak 方法时会调用 Dog 类的 Speak 方法；animal2 指针指向 Cat 对象，因此调用 Speak 方法时会调用 Cat 类的 Speak 方法。

//这种行为是由C++的虚函数和动态绑定机制实现的，允许在运行时根据对象的实际类型来选择正确的函数实现，从而实现了动态多态性。
```

​	**虚函数**：是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

​	**纯虚函数**：在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数,=0告诉这个函数不进行任何动作。

定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

```c++
virtual returnType functionName(parameters) = 0;
```

### 重载

C++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

####  函数重载

​	允许在同一个作用域中定义多个具有相同名称但参数列表不同的函数。这意味着可以为同一个函数名创建多个版本，每个版本接受不同类型或数量的参数。编译器会根据函数调用时提供的参数来选择调用哪个版本的函数。

```c++
#include <iostream>

// 重载的函数，接受两个整数参数
int add(int a, int b) {
    return a + b;
}

// 重载的函数，接受三个整数参数
int add(int a, int b, int c) {
    return a + b + c;
}

// 重载的函数，接受两个浮点数参数
double add(double a, double b) {
    return a + b;
}

int main() {
    int sum1 = add(1, 2);          // 调用第一个版本，整数相加
    int sum2 = add(1, 2, 3);       // 调用第二个版本，整数相加
    double sum3 = add(1.5, 2.5);   // 调用第三个版本，浮点数相加

    std::cout << "Sum 1: " << sum1 << std::endl;
    std::cout << "Sum 2: " << sum2 << std::endl;
    std::cout << "Sum 3: " << sum3 << std::endl;

    return 0;
}
```

####  运算符重载

​	允许重新定义或扩展已存在的运算符的行为，以适应用户自定义类型。通过运算符重载，可以使用户自定义的类对象表现得像内置类型一样，并在操作上使用类似于内置类型的语法。运算符重载使用函数重载的概念来实现，可以在类中定义特殊的成员函数，用于重载特定的运算符。这些成员函数的名称由 **operator** 关键字后面跟着要重载的运算符决定。例如，要重载加法运算符 **+**，可以定义一个名为 **operator+** 的成员函数。

**注意这样做相当运算符左侧的对象在调用名为 运算符的方法 参数为运算符右侧的对象**

```c++
#include <iostream>
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
    	//在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。
      friend ostream &operator<<( ostream &output, 
                                       const Distance &D )
      { 
         output << "F : " << D.feet << " I : " << D.inches;
         return output;            
      }
 
      friend istream &operator>>( istream  &input, Distance &D )
      { 
         input >> D.feet >> D.inches;
         return input;            
      }
};
int main()
{
   Distance D1(11, 10), D2(5, 11), D3;
 
   cout << "Enter the value of object : " << endl;
   cin >> D3;
   cout << "First Distance : " << D1 << endl;
   cout << "Second Distance :" << D2 << endl;
   cout << "Third Distance :" << D3 << endl;
 
 
   return 0;
}
```

下面是可重载的运算符列表：

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                        |
| -------------- | ------------------------------------------------------------ |
| 关系运算符     | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于) |
| 逻辑运算符     | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                          |
| 单目运算符     | + (正)，-(负)，*(指针)，&(取地址)                            |
| 自增自减运算符 | ++(自增)，--(自减)                                           |
| 位运算符       | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符     | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=              |
| 空间申请与释放 | new, delete, new[ ] , delete[]                               |
| 其他运算符     | **()**(函数调用)，**->**(成员访问)，**,**(逗号)，**[]**(下标) |

下面是不可重载的运算符列表：

- **.**：成员访问运算符
- **.\***, **->\***：成员指针访问运算符
- **::**：域运算符
- **sizeof**：长度运算符
- **?:**：条件运算符
- **#**： 预处理符号

## C++进阶

### 文件与流

C++ 中另一个标准库 **fstream**，它定义了三个新的数据类型：

| 数据类型 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。     |
| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。               |
| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |

要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>

* 打开文件

​	从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。

```c++
  void open(const char *filename, ios::openmode mode);
  
  ofstream outfile;
  outfile.open("file.dat", ios::out | ios::trunc );
```

其中mode可以为：

| 模式标志   | 描述                                                         |
  | :--------- | :----------------------------------------------------------- |
  | ios::app   | 追加模式。所有写入都追加到文件末尾。                         |
  | ios::ate   | 文件打开后定位到文件末尾。                                   |
  | ios::in    | 打开文件用于读取。                                           |
  | ios::out   | 打开文件用于写入。                                           |
  | ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |

* 关闭文件

​	C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。

```c++
void close();
ofstream outfile;
outfile.close();
```

* 写入文件

​	使用流入运算符 <<完成写入流

```c++
ofstream outfile;
outfile<<"Output";
```

* 读取文件

```c++
ifstream infile;
infile>>string;
```

* 文件指针

​	**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（"seek get"）和关于 ostream 的 **seekp**（"seek put"）。seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。

```c++
// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）
fileObject.seekg( n );
// 把文件的读指针从 fileObject 当前位置向后移 n 个字节
fileObject.seekg( n, ios::cur );
// 把文件的读指针从 fileObject 末尾往回移 n 个字节
fileObject.seekg( n, ios::end );
// 定位到 fileObject 的末尾
fileObject.seekg( 0, ios::end );
```

**注意**: 输入输出是相对于程序而言而非文件而言，即对程序输入的文件就是输入文件，程序对外输出的文件就是输出文件。也就是说写入文件使用的是输出流，从文件读出使用的是输入流。另外cin，cout如果学习过Linux应该十分容易理解，标准输入输出实际上也是对文件的操作。

### 异常处理

​	异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。

- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。
- **catch:** 在想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。
- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

​	如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。

####  捕获异常

​	程序对try部分的语句捕获相关异常，一旦捕获到即执行相关的catch语句

```c++
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
//如果想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...
try
{
   // 保护代码
}catch(...)
{
  // 能处理任何异常的代码
}
```

####  抛出异常

​	程序检测到相关问题主动抛出异常以让用户注意

```c++
//throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。
throw "ERROR"
```

####  标准异常与自定义异常

##### 标准异常

![](./assets/exceptions_in_cpp.png)

| 异常                   | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| **std::exception**     | 该异常是所有标准 C++ 异常的父类。                            |
| std::bad_alloc         | 该异常可以通过 **new** 抛出。                                |
| std::bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |
| std::bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |
| std::bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |
| **std::logic_error**   | 理论上可以通过读取代码来检测到的异常。                       |
| std::domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |
| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |
| std::length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |
| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 |
| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常。                     |
| std::overflow_error    | 当发生数学上溢时，会抛出该异常。                             |
| std::range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |
| std::underflow_error   | 当发生数学下溢时，会抛出该异常。                             |

##### 自定义异常

在C++中，可以通过继承自基类 std::exception 或其派生类来创建自定义异常类。std::exception 是C++标准库中定义的异常基类，它包含了一些通用的函数，派生类通常需要实现其中的一些或全部函数，以根据特定的异常需求进行自定义。以下是 std::exception 中的一些重要函数和一些自定义异常类可能需要实现的函数：

1. what(): 这是 std::exception 中最重要的函数，它返回一个描述异常的C字符串（const char*）。自定义异常类通常需要重写这个函数，以提供关于异常的详细信息。
2. virtual const char* what() const throw(): 这是 what() 函数的标准签名。what() 函数应该被声明为虚函数，并且通常应该在异常类的实现中提供具体的异常描述。
3. 构造函数和析构函数：通常情况下，自定义异常类应该具有构造函数和析构函数，以便正确初始化和清理异常对象。

```c++
#include <iostream>
#include <exception>

class MyException : public std::exception {
private:
    std::string errorMessage;

public:
    MyException(const std::string& message) : errorMessage(message) {}

    // 实现 what() 函数，返回异常描述
    const char* what() const throw() {
        return errorMessage.c_str();
    }
};

int main() {
    try {
        // 抛出自定义异常
        throw MyException("This is a custom exception");
    } catch (const std::exception& e) {
        // 捕获并处理异常
        std::cerr << "Caught Exception: " << e.what() << std::endl;
    }

    return 0;
}
```

####  异常规范

 如果某个函数可能抛出异常，在明确异常类型时，可以使用throw()描述异常

```c++
#include <stdexcept>

void Fun() throw(ExceptionType1, ExceptionType2, std::runtime_error) {
    // 函数体
}

void Fun() noexcept {
    // 函数体
}

```

throw() 是异常规范（exception specification）的一部分，用于指定函数不会抛出任何异常。在旧的C++标准中，它被用于文档化和承诺函数的异常安全性，并帮助编译器进行一些优化。然而，在新的C++标准中，更推荐使用 noexcept 关键字来表示函数不会抛出异常，因为它提供了更灵活的异常规范方式。

具体来说，throw() 的意义包括：

1. **文档化异常安全性：** 异常规范可以在函数的文档中明确说明函数的异常行为，帮助其他程序员了解哪些函数不会引发异常，从而更好地编写安全的代码。
2. **编译器优化：** 旧的C++编译器可能会根据 throw() 异常规范来进行某些优化，因为它知道函数不会抛出异常，从而可以生成更高效的代码。

然而，需要注意的是，throw()并不是一个强制性规范，它不会阻止函数抛出异常，也不会在运行时捕获异常。如果函数使用 throw()声明不会抛出异常，但实际上抛出了异常，程序会调用 std::unexpected，默认情况下会导致程序终止。因此，对于函数是否抛出异常的确切情况，还需要依赖于函数的实际实现。

在新的C++标准中，noexcept 关键字提供了更灵活和更明确的异常规范方式，它明确表示函数不会抛出异常，同时也可以用于处理异常。因此，如果的目标是表示函数不会抛出异常，建议使用 noexcept 来取代 throw()。

### 动态内存

C++ 程序中的内存分为两个部分：

- **栈：**在函数内部声明的所有变量都将占用栈内存。
- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。

​	很多时候，无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。在 C++ 中，可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。如果不再需要动态分配的内存空间，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。

####  new运算符

​	new操作符会根据其后指定的类型来分配内存，并返回分配内存的起始地址。当你使用 new 来分配内存时，它会根据指定的类型确定要分配多少内存，并返回该内存块的起始地址，以便你可以将其赋值给相应类型的指针或对象。new在申请内存并根据类型创建对象时会自己调用相关构造函数。

```c++
new data-type;
//如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针
//建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。
double* pvalue  = NULL;
if( !(pvalue  = new double ))
{
   cout << "Error: out of memory." <<endl;
   exit(1);
 
}
```

####  delete运算符

​	delete将之前分配的内存块标记为可用，以便操作系统可以重新利用这块内存。如果不使用delete来释放内存，就会导致内存泄漏，即程序无法访问这块内存，但该内存仍然被占用，最终可能导致程序耗尽可用内存。delete在释放内存前会自己调用相关析构函数。

```c++
delete obj;
delete pvalue;  
```

在C++中，必须与new和new[]匹配使用delete和delete[]。

### 命名空间

​	C++中的命名空间（Namespace）是一种用于组织和管理标识符（如变量、函数、类等）的方式，以避免命名冲突并提高代码的可维护性。命名空间定义了一个作用域，其中可以包含各种标识符，这些标识符在该命名空间内是唯一的，但可以与其他命名空间内的标识符重名而不会发生冲突。

命名空间的语法如下：

```c++
namespace namespace_name {
    vartype var;
    // 在这里定义变量、函数、类等
}
namespace_name::var;
```

​	使用 **using namespace** 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。例如 std 命名空间，你经常会看到 using namespace std; 来简化标准库的使用。但要注意，在大型项目中，滥用命名空间可能会引入新的问题，因此需要谨慎使用。using 指令也可以用来指定命名空间中的特定项目。

**注意：命名空间允许分散定义，允许嵌套定义；但是不同文件的同名空间是被认为两个空间的**

### 模板

C++模板是一种强大的特性，它允许你编写通用的代码，不依赖于特定的数据类型。使用模板，你可以编写函数模板和类模板，以便在不同数据类型上重用相同的算法和数据结构。

以下是关于C++模板的一些基本概念：

1. **函数模板**：

   函数模板允许你编写一个通用的函数，其中某些类型可以是通用的，而不是具体的。你可以使用template关键字定义一个函数模板，然后在函数内部使用模板参数。例如：

   ```
   template <typename type> ret-type func-name(parameter list)
   {
      // 函数的主体
   }
   /********************************************************/
   #include <iostream>
   #include <string>
    
   using namespace std;
    
   template <typename T>
   inline T const& Max (T const& a, T const& b) 
   { 
       return a < b ? b:a; 
   } 
   int main ()
   {
    
       int i = 39;
       int j = 20;
       cout << "Max(i, j): " << Max(i, j) << endl; 
    
       double f1 = 13.5; 
       double f2 = 20.7; 
       cout << "Max(f1, f2): " << Max(f1, f2) << endl; 
    
       string s1 = "Hello"; 
       string s2 = "World"; 
       cout << "Max(s1, s2): " << Max(s1, s2) << endl; 
    
       return 0;
   }
   ```

2. **类模板**：

   类模板允许你编写通用的类，其中某些数据成员或成员函数的类型可以是通用的。类模板的定义类似于函数模板，但用于定义类。例如：

   ```
   template <class type> class class-name {
   .
   .
   .
   }
   /*********************************************************************/
   #include <iostream>
   #include <vector>
   #include <cstdlib>
   #include <string>
   #include <stdexcept>
    
   using namespace std;
    
   template <class T>
   class Stack { 
     private: 
       vector<T> elems;     // 元素 
    
     public: 
       void push(T const&);  // 入栈
       void pop();               // 出栈
       T top() const;            // 返回栈顶元素
       bool empty() const{       // 如果为空则返回真。
           return elems.empty(); 
       } 
   }; 
    
   template <class T>
   void Stack<T>::push (T const& elem) 
   { 
       // 追加传入元素的副本
       elems.push_back(elem);    
   } 
    
   template <class T>
   void Stack<T>::pop () 
   { 
       if (elems.empty()) { 
           throw out_of_range("Stack<>::pop(): empty stack"); 
       }
       // 删除最后一个元素
       elems.pop_back();         
   } 
    
   template <class T>
   T Stack<T>::top () const 
   { 
       if (elems.empty()) { 
           throw out_of_range("Stack<>::top(): empty stack"); 
       }
       // 返回最后一个元素的副本 
       return elems.back();      
   } 
    
   int main() 
   { 
       try { 
           Stack<int>         intStack;  // int 类型的栈 
           Stack<string> stringStack;    // string 类型的栈 
    
           // 操作 int 类型的栈 
           intStack.push(7); 
           cout << intStack.top() <<endl; 
    
           // 操作 string 类型的栈 
           stringStack.push("hello"); 
           cout << stringStack.top() << std::endl; 
           stringStack.pop(); 
           stringStack.pop(); 
       } 
       catch (exception const& ex) { 
           cerr << "Exception: " << ex.what() <<endl; 
           return -1;
       } 
   }
   ```

### 预处理

​	C++预处理是C++编译过程的第一个阶段，它在实际编译之前执行。预处理器是负责执行预处理的一部分编译器，通常在编译之前独立运行。预处理器的主要任务是处理源代码中的预处理指令（以 # 开头），并生成修改后的代码，以供实际的编译器进一步处理。只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。

预处理器主要完成以下任务：

* **包含头文件**：#include 指令用于包含其他文件的内容，通常用于包含标准库头文件或用户自定义头文件。
* **宏替换**：宏定义（#define 指令）允许你创建代码中的常量或简单函数替换。在预处理阶段，宏会被替换为其定义的文本。

```c++
#define macro-name replacement-text 
//常量宏
#include <iostream>
using namespace std;
#define PI 3.14159
int main ()
{
    cout << "Value of PI :" << PI << endl; 
    return 0;
}
//参数宏  注意函数宏只是简单的替换，并不会处理优先级
#include <iostream>
using namespace std;
#define MIN(a,b) (a<b ? a : b)
int main ()
{
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl;
   return 0;
}
```



* **条件编译**：条件编译指令（例如#ifdef、#ifndef、#if、#elif、#else、#endif 等）用于根据条件选择性地包含或排除代码块。

* **删除注释**：注释（// 和 /* */）在预处理阶段通常会被删除，以减少编译后的代码大小。

* **其他预处理指令**：还有其他一些预处理指令，如 #pragma 指令，用于控制编译器的行为。

在执行预处理之后，生成的代码将被传递给实际的编译器，然后进行编译、链接和生成可执行文件等后续步骤。

* \# 和 ## 都是C++预处理器中的特殊符号，用于在宏定义中进行文本操作。

  1. \#（井号）操作符：它用于将宏参数转换为字符串常量。这个操作符在宏定义中的参数前面使用，将参数的内容包装在双引号中。这对于创建带参数的消息或日志非常有用。

     ```c++
     #define STRINGIFY(x) #x
     std::cout << STRINGIFY(Hello, World) << std::endl; // 输出 "Hello, World"
     //在这个示例中，#x 将宏参数 x 转换为字符串常量，所以 STRINGIFY(Hello, World) 输出的是字符串 "Hello, World"
     ```

  2. \##（双井号）操作符：它用于在宏定义中进行标识符的连接操作。这个操作符允许你将两个标识符组合成一个单一的标识符。

     ```c++
     #define CONCAT(x, y) x##y
     int xy = CONCAT(10, 20); // 生成 int xy = 1020;
     //在这个示例中，CONCAT(10, 20) 将参数 x 和 y 连接成了一个标识符 xy，最终生成了 int xy = 1020;。
     ```

C++ 提供了下表所示的一些预定义宏：

| 宏       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| __LINE__ | 这会在程序编译时包含当前行号。                               |
| __FILE__ | 这会在程序编译时包含当前文件名。                             |
| __DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |
| __TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |

### 信号处理

​	C++中的信号处理是一种用于处理异步事件的机制。信号是一种在程序执行过程中由操作系统或其他进程发送的异步通知机制，用于处理诸如中断、错误、异常等事件。在C++中，你可以使用标准库中的 <csignal> 头文件来处理信号。

​	信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。以下为一些常见信号。

| 信号    | 描述                                         |
| :------ | :------------------------------------------- |
| SIGABRT | 程序的异常终止，如调用 **abort**。           |
| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |
| SIGILL  | 检测非法指令。                               |
| SIGINT  | 程序终止(interrupt)信号。                    |
| SIGSEGV | 非法访问内存。                               |
| SIGTERM | 发送到程序的终止请求。                       |

以下是一些关于C++信号处理的基本概念和步骤：

1. **包含头文件**：首先，你需要包含  <csignal>  头文件以访问与信号处理相关的函数和宏。

   ```
   #include <csignal>
   ```

2. **注册信号处理函数**：你可以使用  std::signal  函数来注册信号处理函数。该函数接受两个参数，第一个参数是要处理的信号，第二个参数是一个函数指针，指向你自己编写的信号处理函数。

   ```
   #include <iostream>
   #include <csignal>
   
   void signalHandler(int signum) {
       std::cout << "Received signal: " << signum << std::endl;
   }
   
   int main() {
       // 注册信号处理函数
       std::signal(SIGINT, signalHandler);
   
       // 无限循环以等待信号
       while (true) {
           // 你的应用程序代码
       }
   
       return 0;
   }
   ```

   在上面的示例中，我们注册了一个信号处理函数  signalHandler  来处理  SIGINT  信号（通常由用户按下 Ctrl+C 发送），当程序接收到该信号时，将调用  signalHandler  函数。

3. **处理信号**：一旦信号被发送，注册的信号处理函数将被调用，可以在信号处理函数中执行你需要的操作。在示例中，我们简单地打印了接收到的信号编号。

4. **发出信号:**主动向当前进程发起信号

   ```
   int raise (signal sig);
   ```
   
5. **恢复默认处理行为**：你还可以使用  std::signal  函数将信号处理函数设置为默认处理行为，或者在处理完信号后继续注册新的处理函数。

   ```
   // 恢复默认处理行为
   std::signal(SIGINT, SIG_DFL);
   ```

注意事项：

- 信号处理函数应该是轻量级的，因为它们在异步上下文中执行，不应该执行长时间运行的操作。
- 不同的操作系统和平台可能支持不同的信号，因此要根据你的需求选择适当的信号。
- 信号处理不适合所有情况，尤其是在多线程程序中，因为信号是进程级别的，而不是线程级别的。

​	在现代C++中，通常建议使用更安全的异步处理方式，如使用线程和互斥锁，而不是依赖信号处理来处理异步事件。然而，对于一些特定的系统级任务，信号处理仍然是一种有用的机制。

### 多线程

​	多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。

- 基于进程的多任务处理是程序的并发执行。
- 基于线程的多任务处理是同一程序的片段的并发执行。

​	多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。本教程假设使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。

####  创建线程

```c++
#include <pthread.h>
pthread_create (thread, attr, start_routine, arg) 
```

​	在这里，**pthread_create** 创建一个新的线程，并让它可执行。下面是关于参数的说明：

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| thread        | 指向线程标识符指针。                                         |
| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |
| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |
| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |

创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。

####  终止线程

```c++
#include <pthread.h>
pthread_exit (status) 
```

​	在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。

####  分离和连接线程

```c++
pthread_join (threadid, status) 
pthread_detach (threadid) 
```

​	pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。

####  C++标准线程

```c++
#include <iostream>
#include <thread>
std::thread::id main_thread_id = std::this_thread::get_id();

void hello()  
{
    std::cout << "Hello Concurrent World\n";
    if (main_thread_id == std::this_thread::get_id())
        std::cout << "This is the main thread.\n";
    else
        std::cout << "This is not the main thread.\n";
}

void pause_thread(int n) {
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout << "pause of " << n << " seconds ended\n";
}

int main() {
    std::thread t(hello);
    std::cout << t.hardware_concurrency() << std::endl;//可以并发执行多少个(不准确)
    std::cout << "native_handle " << t.native_handle() << std::endl;//可以并发执行多少个(不准确)
    t.join();
    std::thread a(hello);
    a.detach();
    std::thread threads[5];                         // 默认构造线程

    std::cout << "Spawning 5 threads...\n";
    for (int i = 0; i < 5; ++i)
        threads[i] = std::thread(pause_thread, i + 1);   // move-assign threads
    std::cout << "Done spawning threads. Now waiting for them to join:\n";
    for (auto &thread : threads)
        thread.join();
    std::cout << "All threads joined!\n";
}
```

### STL

C++标准模板库（STL，Standard Template Library）是C++标准库的一部分，它提供了一组通用的模板类和函数，用于处理各种常见的数据结构和算法。STL使C++程序员能够以高效、可重用的方式操作数据。

STL的主要组件包括以下内容：

1. **容器（Containers）**：STL提供了各种容器，用于存储和管理数据。常见的容器包括：
   - vector：动态数组
   - list：双向链表
   - deque：双端队列
   - set：集合，无序且不允许重复元素
   - map：映射，键-值对的集合
   - unordered_set：无序集合，无序但不允许重复元素
   - unordered_map：无序映射，键-值对的无序集合
2. **迭代器（Iterators）**：迭代器是一种通用的方式来遍历容器中的元素，使得算法可以独立于容器的具体类型而工作。
3. **算法（Algorithms）**：STL提供了一系列通用的算法，可以应用于各种容器，包括排序、搜索、遍历等。
4. **函数对象（Function Objects）**：STL中的函数对象（也称为functors）是可以像函数一样调用的对象，通常用于自定义排序和操作。
5. **配接器（Adapters）**：配接器是用于修改容器接口的类，例如 stack 和 queue 分别是基于 deque 的适配器，提供了堆栈和队列的接口。

6. **空间配置器**：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.

####  容器

#####vector介绍

​	连续存储结构，每个元素在内存上是连续的；支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；相当于一个数组，但是与数组的区别为：内存空间的扩展。vector支持不指定vector大小的存储，但是数组的扩展需要程序员自己写。
优点：

* 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()

* 随机访问方便，即支持[ ]操作符和vector.at()

* 节省空间

缺点：

* 在内部进行插入删除操作效率低
* 只能在vector的最后进行push和pop，不能在vector的头进行push和pop
* 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放

vector的使用:在头文件中包含#include <vector>；vector属于std命名域的，因此需要通过命名限定using std::vector或using namespace std;



vector的声明：

* vector<Type> c;	创建一个空的vector;
* vector<Type> c1(c2);	创建一个vector c1，并用c2去初始化c1;
* vector<Type> c(n) ;	创建一个含有n个Type类型数据的vector;
* vector<Type> c(n,elem);	创建一个含有n个Type类型数据的vector,并全部初始化为elem;
* vector<Type> vector(begin,end);	创建一个从begin到end的vector;
* c.~vector<ElemType>();	销毁所有数据,释放资源;

vetcor的函数：

* c.push_back(elem);	在容器最后位置添加一个元素elem
* c.pop_back();	删除容器最后位置处的元素
* c.at(index);	返回指定index位置处的元素
* c.begin();	返回指向容器最开始位置数据的指针
* c.end();	返回指向容器最后一个数据单元的指针+1
* c.front();	返回容器最开始单元数据的引用
* c.back();	返回容器最后一个数据的引用
* c.max_size();	返回容器的最大容量
* c.size();	返回当前容器中实际存放元素的个数
* c.capacity();	容器需要增长之前，能够盛的元素总数
* c.resize(size_type size, TYPE val);	重新设置vector的容量
* c.reserve(size_type size);	预留至少共容纳size个元素的空间.
* c.erase(p);    删除指针p指向位置的数据，返回指向下一个数据位置的指针（迭代器）
* c.erase(begin,end);    删除begin,end区间的数据，返回指向下一个数据位置的指针（迭代器）
* c.clear();	清除所有数据
* c.rbegin();	将vector反转后的开始指针返回(就是原来的end-1)
* c.rend();	将vector反转后的结束指针返回(就是原来的begin-1)
* c.empty();	判断容器是否为空，若为空返回true，否则返回false
* c1.swap(c2);	交换两个容器中的数据
* c.insert(p,elem);    在指针p指向的位置插入数据elem,返回指向elem位置的指针
  c.insert(p,n,elem);    在位置p插入n个elem数据，无返回值
  c.insert(p,begin,end);   在位置p插入在区间[begin,end)的数据，无返回值


```c++
#include <iostream>
#include <vector>
#include <algorithm>
// #include <list>
// #include <queue>
// #include <map>

using namespace std;
/* 遍历方式1 ：迭代器的方式遍历*/
void PrintVector(vector<int> &v)
{
    /* 容器遍历：利用begin和end迭代器方式 */
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
/* 遍历方式2 ：size方式数组下标方式*/
void PrintVector_size(vector<int> &v)
{
    for (std::vector<int>::size_type i = 0; i != v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
}
/* 遍历方式3 ：平常使用更推荐auto，速度更快，需要C++11支持*/
void PrintVector_auto(vector<int> &v)
{
    for (auto const &value : v)
    {
        cout << value << " ";
    }
    cout << endl;
}

/* 遍历方式4 ：如果在遍历的过程中需要更改其中的数据更推荐使用本方法，需要C++17支持*/
template <typename T>
void printer(const T &val)
{
    cout << val << " ";
}
void PrintVector_for_each(vector<int> &v)
{
    //#include <algorithm>使用需要包含
    for_each(v.cbegin(), v.cend(), printer<int>);
    cout << endl;
}

int main(int argc, char **argv)
{
    vector<int> v1; //初始化方式1:无初始值
    /* 容器赋值 */
    for (int i = 0; i < 10; i++)
    {
        v1.push_back(i * 10);
    }
    cout << "V1: ";
    PrintVector(v1);
    v1.pop_back(); //删除最后一位数据
    cout << "V1: ";
    PrintVector(v1);

    vector<int> v2(10, 1); //初始化方式2:赋值10个1
    cout << "V2: ";
    PrintVector(v2);

    v1.swap(v2); //交换两个容器的数据
    cout << "V1: ";
    PrintVector(v1);
    cout << "V2: ";
    PrintVector(v2);

    cout << "V1元素个数：" << v1.size() << endl;
    v1.insert(v1.begin() + 5, 2, 8); //在容器元素第五个的后面插入两个8
    cout << "V1: ";
    PrintVector(v1);

    v1.erase(v1.begin() + 5); //删除第五个元素
    cout << "V1: ";
    PrintVector(v1);

    v1.erase(v1.begin() + 5, v1.end()); //删除第五个元素到最后一个元素的数据
    cout << "V1: ";
    PrintVector(v1);

    int &vNum1 = v1.front(); //返回容器V1的第一个元素的引用
    //如果这里定义的不是&元素则无法更改v1的内容，而这里却可以
    //front、back与end、begin的区别在于返回的一个是引用一个是迭代器
    int &vNum2 = v1.back(); //返回容器V1的最后一个元素的引用

    if (!v1.empty())
    {
        v1.clear(); //如果不为空则清空容器
    }
    cout << "V1: ";
    PrintVector(v1);

    vector<int> v3;
    v3.resize(10, 5); //指定空间大小
    cout << "V3的容量 = " << v3.capacity() << endl;
    cout << "V3:";
    PrintVector_auto(v3);

    cout << "V3:";
    PrintVector_for_each(v3);

    reverse(v2.begin(), v2.end()); //逆序储存从开始位置到结束位置，需要包含头文件#include <algorithm>
    PrintVector_auto(v2);

    return 0;
}

```

##### deque介绍

​	连续存储结构， deque是在功能上合并了vector和list。即其每个元素在内存上也是连续的，类似于vector。不同之处在于，deque提供了两级数组结构， 第一级完全类似于vector，代表实际容器；另一级为容器的首位地址。这样，deque除了具有vector的所有功能外，还支持高效的首/尾端插入/删除操作。

优点：

* 随机访问方便，即支持[ ]操作符和vector.at()

* 在内部方便的进行插入和删除操作

* 可在两端进行push、pop

缺点：
* 占用内存多
* 支持随机访问，即支持[]以及at()，但是性能没有vector好
* 可以在内部进行插入和删除操作，但性能不及list

使用区别：

* 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
* 如果你需要大量的插入和删除，而不关心随即存取，则应使用list
* 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque

deque的使用:在头文件中包含#include <deque>；deque属于std命名域的，因此需要通过命名限定using std::deque或using namespace std;



deque的声明：

* deque <Type> deque;	创建一个空的deque;
* deque<Type> deque1(deque2);	创建一个deque deque1，并用deque2去初始化deque1;
* deque <Type> deque(n) ;	创建一个含有n个Type类型数据的deque;
* deque<Type> deque(n,elem);	创建一个含有n个Type类型数据的deque ,并全部初始化为elem;
* deque<Type> deque(begin,end);	创建一个从begin到end的deque；
*  c.~deque<ElemType>();	销毁所有数据,释放资源;

deque的函数：

* deque.at(index);	返回指定index位置处的元素
* deque.push_front (num);	从前面向deque中添加数据
* deque.push_back (num);	从后面向deque中添加数据
* deque.pop_front ();	删除第一个元素
* deque.pop_back ();	删除最后一个元素
* deque.begin();	返回指向容器最开始位置数据的指针
* deque.end();	返回指向容器最后一个数据单元的指针+1
* deque.front();	返回容器最开始单元数据的引用
* deque.back();	返回容器最后一个数据的引用
* deque.max_size();	返回容器的最大容量
* deque.size();	返回当前容器中实际存放元素的个数
* deque.resize(size_type size, TYPE val);	重新设置deque的容量
* deque.erase(p);   删除指针p指向位置的数据，返回指向下一个数据位置的指针（迭代器）
* deque.erase(begin,end);删除begin,end区间的数据，返回指向下一个数据位置的指针（迭代器）
* deque.clear();	清除所有数据
* deque.rbegin();	将deque反转后的开始指针返回(就是原来的end-1)
* deque.rend();	将deque反转后的结束指针返回(就是原来的begin-1)
* deque.empty();	判断容器是否为空，若为空返回true，否则返回false
* deque1.swap(deque2);	交换两个容器中的数据
* deque.insert(p,elem);    在指针p指向的位置插入数据elem,返回指向elem位置的指针
* deque.insert(p,n,elem);    在位置p插入n个elem数据，无返回值
* deque.insert(p,begin,end);    在位置p插入在区间[begin,end)的数据，无返回值
* deque.assign(n.elem)  将n个elem的拷贝赋值给deque
* deque.assign(bedin,end)    将[begin,end)区间的数据赋值给deque




```c++
#include <iostream>
#include <deque>
#include <algorithm>
using namespace std;

template <typename T>
void printer(const T &val)
{
    cout << val << " ";
}
//for_each遍历方式
void PrintVector_for_each(deque<int> &deq)
{
    //#include <algorithm>使用需要包含
    for_each(deq.cbegin(), deq.cend(), printer<int>);
    cout << endl;
}

int main(int argc, char **argv)
{
    deque<int> deq1;
    for (int i = 0; i < 5; i++)
    {
        deq1.push_back(i * 10);
    }
    //从队列前面插入数据
    for (int i = 25; i > 20; i--)
    {
        deq1.push_front(i * 10);
    }
    //从队列后面插入数据
    for (int i = 10; i > 5; i--)
    {
        deq1.push_back(i * 10);
    }
    PrintVector_for_each(deq1);
	//除了前后插入与vector容器使用方法相同
    return 0;
}
```

##### list介绍

​	非连续存储结构，具有双链表结构，每个元素有一对前向和后向指针，支持前向/后向遍历。高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。每一个结点都包括一个信息块Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。

 优点：

* 不使用连续内存完成动态操作
* 在内部方便的进行插入和删除操作
* 可在两端进行push、pop

缺点：

* 不能进行内部的随机访问，即不支持[ ]操作符和at()
* 相对于verctor占用内存多

list的使用:在头文件中包含#include <list>；vector属于std命名域的，因此需要通过命名限定using std::list或using namespace std;



list的声明：

* list<Type> list ;	创建一个空的list;
* list<Type> list1(list2);	创建一个list list1，并用list2去初始化list1;
* list<Type> list(n) ;	创建一个含有n个Type类型数据的list;
* list<Type> list(n,elem);	创建一个含有n个Type类型数据的list,并全部初始化为elem;
* list <Type> list(begin,end);	创建一个从begin到end的list；
*  c.~list<ElemType>();	销毁所有数据,释放资源;

list的函数：

* list.push_front (num);	从前面向list中添加数据
* list.push_back (num);	从后面向list中添加数据
* list.pop_front ();	删除第一个元素
* list.pop_back ();	删除最后一个元素
* list.begin();	返回指向容器最开始位置数据的指针
* list.end();	返回指向容器最后一个数据单元的指针+1
* list.front();	返回容器最开始单元数据的引用
* list.back();	返回容器最后一个数据的引用
* list.max_size();	返回容器的最大容量
* list.size();	返回当前容器中实际存放元素的个数
* list.capacity();	同c.size()
* list.resize(size_type size, TYPE val);	重新设置deque的容量
* list.reserve(size_type size);	预留至少共容纳size个元素的空间.
* list.erase(p);  删除指针p指向位置的数据，返回指向下一个数据位置的指针（迭代器）
* list.erase(begin,end);    删除begin,end区间的数据，返回指向下一个数据位置的指针（迭代器）
* list.remove();	删除一个元素,参数是元素的值或者是对象
* list.clear();	清除所有数据
* list.rbegin();	将list反转后的开始指针返回(就是原来的end-1)
* list.rend();	将list反转后的结束指针返回(就是原来的begin-1)
* list.empty();	判断容器是否为空，若为空返回true，否则返回false
* list1.swap(list2);	交换两个容器中的数据
* list.insert(p,elem);    在指针p指向的位置插入数据elem,返回指向elem位置的指针
* list.insert(p,n,elem);    在位置p插入n个elem数据，无返回值
* list.insert(p,begin,end);    在位置p插入在区间[begin,end)的数据，无返回值
* list1.merge(list2);	合并两个list(list1和list2已经排好顺序，合并之后list1仍然是有序的)
* index=find(list1.begin(),list1.end(),'f');   先的找到要插入的位置，在该位置的前一个插入；
* list1.splice(index,list2);    将第二个链表插入到第一个链表中
* list1.splice(index1, list2, index2);    将list2中的元素index2，合并到list1的index1之前
* list1.splice(index1,list2,index2,index3);    把链表list2中的一段插入到另一个链表list1中
* list.unique();	删除list中重复的元素
* list.sort();	将list里的元素排序
* list.reverse();	将list里的数据倒序排列
* list.assign(n.elem)  将n个elem的拷贝赋值给list
* list.assign(bedin,end)  将[begin,end)区间的数据赋值给list

```c++
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

template <typename T>
void printer(const T &val)
{
    cout << val << " ";
}
void printList_for_each(list<int> &lst)
{
    for_each(lst.cbegin(), lst.cend(), printer<int>);
    cout << endl;
}

int main(int argc, char **argv)
{
    list<int> lst1;
    lst1.push_back(7);
    lst1.push_back(4);
    lst1.push_back(1);
    lst1.push_back(6);
    lst1.push_back(5);
    lst1.push_back(2);
    lst1.push_back(3);
    cout << "List1:";
    printList_for_each(lst1);

    list<int> lst2(lst1.begin(), lst1.end());
    cout << "List2:";
    printList_for_each(lst2);
    lst2.sort();
    cout << "List2:";
    printList_for_each(lst2);

    //相对于vector和deque新增的使用方法
    lst1.assign(lst2.begin(), lst2.end()); //分配值
    cout << "List1:";
    printList_for_each(lst1);

    //删除相同元素
    lst1.push_back(1);
    lst1.push_back(1);
    cout << "List1:";
    printList_for_each(lst1);

    lst1.remove(1); //删除列表中所有的1元素
    cout << "List1:";
    printList_for_each(lst1);

    lst1.push_front(2);
    lst1.push_front(2);
    lst1.push_front(2);
    cout << "List1:";
    printList_for_each(lst1);
    lst1.unique(); //删除相邻重复元素
    cout << "List1:";
    printList_for_each(lst1);

    //将 lst1中的首元素移到 lst1的最后
    lst1.splice(lst1.end(), lst1, lst1.begin());
    cout << "List1:";
    for (list<int>::iterator it = lst1.begin(); it != lst1.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    //将 lst2中的所有元素移到 lst1的最后
    lst1.splice(lst1.end(), lst2);
    cout << "List1:";
    for_each(lst1.begin(), lst1.end(), [](int val) { cout << val << " "; });

	//这个我暂时没找到什么作用
    lst1.rbegin(); //返回第一个元素的前向指针
    return 0;
}
```

##### map介绍

​	map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。map内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。

map的使用:在头文件中包含#include <map>；deque属于std命名域的，因此需要通过命名限定using std::deque或using namespace std;

map的函数：

* map.find()	查找一个元素，如果容器中不存在该元素，返回值等于map.end()
* map.count()	统计map中某个键值出现的次数，因为map中键值唯一，所以此方法可以用来检测某键值是否存在
* map.lower_bound()	返回要查找关键字的下界(是一个迭代器)
* map.upper_bound()	返回要查找关键字的上界(是一个迭代器)
* map.equal_range()	pair里面第一个变量是lower_bound返回的迭代器，pair里面第二个迭代器map.upper_bound返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字
* map.size();	返回当前容器中实际存放元素的个数
* map.erase(val);  删除关键字删除
* map.erase(p);  删除指针p指向位置的数据，返回指向下一个数据位置的指针（迭代器）
* map.erase(begin,end);  删除begin,end区间的数据，返回指向下一个数据位置的指针（迭代器）
* map.clear();	清除所有数据
* map.empty();	判断容器是否为空，若为空返回true，否则返回false
* map1.swap(map2);	交换两个容器中的数据
* map.insert(pair<int,string>(1, “one”)); 当map中有这个关键字时，insert操作是插入数据不了的
* map.insert(map<int,string>::value_type (1, “one”));
* map[1] = “one”; 数组方式就不同，它可以覆盖以前该关键字对应的值




```c++
/*
 * @Author: Stylle
 * @Date: 2020-08-23 16:32:10
 * @LastEditors: Stylle
 * @LastEditTime: 2020-08-23 20:45:41
 * @FilePath: \c-master\常用容器map的使用.cpp
 */
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main(int argc, char **argv)
{
    map<int, string> map1;

    //常用操作方法
    map1[3] = "Three";                                   //添加元素
    map1.insert(map<int, string>::value_type(2, "Two")); //插入元素1
    map1.insert(pair<int, string>(4, "Four"));           //插入元素2
    map1.insert(make_pair<int, string>(1, "One"));       //插入元素3

    string str = map1[3];                               //根据key取得value，key不能修改
    map<int, string>::iterator iter_map = map1.begin(); //取得迭代器首地址
    int key = iter_map->first;                          //取得eky
    string value = iter_map->second;                    //取得value
    map1.erase(iter_map);                               //删除迭代器数据

    //遍历方式1
    for (map<int, string>::iterator it = map1.begin(); it != map1.end(); it++)
    {
        //遍历输出key  value
        cout << it->first << " " << it->second << endl;
    }
    map1.erase(3); //根据key删除value
    //遍历方式2：使用auto指针
    for (auto it = map1.begin(); it != map1.end(); it++)
    {
        cout << it->first << " " << it->second << endl;
    }

    return 0;
}
```

##### set介绍

​	set容器用来存储唯一元素，并且这些元素按照一定的规则排序，其内部数据结构为红黑树。在一个集合里面，每个元素同时也是自身的关键字，与map相比，set的key与value是同一个值，所以每个元素必须是唯一的。同时，一旦某个元素插入到容器内，则不能修改其中任何元素，类比map，在map中也不能修改key。但set容器可以插入与删除。

set的使用:在头文件中包含#include <set>；deque属于std命名域的，因此需要通过命名限定using std::deque或using namespace std;



set的声明：

* set <Type> deque;	创建一个空的set;
* set<Type> set1(set2);	创建一个set1，并用set2去初始化set1;
* set <Type> set(n) ;	创建一个含有n个Type类型数据的set;
* set<Type> set(n,elem);	创建一个含有n个Type类型数据的set,并全部初始化为elem;
* set<Type> set(begin,end);	创建一个从begin到end的set；
*  c.~set<ElemType>();	销毁所有数据,释放资源;

set的函数：

* set.begin();	返回指向容器最开始位置数据的指针
* set.end();	返回指向容器最后一个数据单元的指针+1
* set.find()	查找一个元素，如果容器中不存在该元素，返回值等于s.end()
* set.lower_bound()	返回第一个大于或等于给定关键值的元素
* set.upper_bound()	返回第一个大于给定关键值的元素
* set.equal_range()	返回一对定位器，分别表示 第一个大于或等于给定关键值的元素 和 第一个大于给定关键值的元素，这个返回值是一个pair类型，如果这一对定位器中哪个返回失败，就会等于s.end()
* set.size();	返回当前容器中实际存放元素的个数
* set.erase(p);    删除指针p指向位置的数据，返回指向下一个数据位置的指针（迭代器）
* set.erase(begin,end);   删除begin,end区间的数据，返回指向下一个数据位置的指针（迭代器）
* set.clear();	清除所有数据
* set.empty();	判断容器是否为空，若为空返回true，否则返回false
* set.insert(p,elem);    在指针p指向的位置插入数据elem,返回指向elem位置的指针
* set.insert(p,n,elem);    在位置p插入n个elem数据，无返回值
* set.insert(p,begin,end);    在位置p插入在区间[begin,end)的数据，无返回值



```c++
#include <iostream>
#include <set>
#include <algorithm>
#include <random>
#include <ctime>
using namespace std;
int main(int argc, char **argv)
{
    set<string> set1;
    set1.insert("one"); //第一种方法：直接添加
    set1.insert("two");

    set<string> set2;
    set2.insert(set1.begin(), set1.end()); //第二中方法：通过指针迭代器

    //迭代器遍历set容器
    cout << "Set2:";
    for (auto it = set2.begin(); it != set2.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    set<int> set3;
    srand((unsigned)time(NULL));
    for (int i = 0; i < 10; i++)
    {
        set3.insert(rand() % 10);
    }
    cout << "Set3:";
    for (auto it = set3.begin(); it != set3.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    if (!set3.count(6)) //存在，返回1,不存在，返回0
    {
        set3.insert(6);
    }
    set3.find(1); // 返回指向元素内容为1的指针
    cout << "Set3:";
    for (auto it = set3.begin(); it != set3.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    return 0;
}
```

##### 其他常用容器

1. **std::unordered_map** 和 **std::unordered_set**：这些容器提供了基于哈希表的数据结构，用于快速的查找和插入操作。与`std::map`和`std::set`（基于红黑树）不同，这些容器没有排序功能，但在查找和插入方面通常更快。
2. **std::multimap** 和 **std::multiset**：这些容器是`std::map`和`std::set`的变种，允许存储具有相同键值的多个元素。它们通常用于需要存储重复键的情况。
3. **std::deque**：双端队列是一个支持在两端高效插入和删除的容器，适用于需要频繁的前后插入和删除操作的情况。
4. **std::priority_queue**：优先队列是一个用于实现优先级队列的容器，通常用于贪心算法和Dijkstra等算法中。它基于堆数据结构实现，允许高效地获取最大或最小值。
5. **std::bitset**：位集容器允许你以位为单位存储和操作数据，通常用于位掩码和位运算。
6. **std::array**：数组容器是一个固定大小的数组，类似于内置数组，但提供了STL风格的接口和安全性。
7. **std::valarray**：值数组容器用于数值计算，提供了一组数学运算符，用于对数组中的元素执行数学运算。
8. **std::unordered_multimap** 和 **std::unordered_multiset**：这些是允许重复键的哈希容器，类似于`std::multimap`和`std::multiset`，但基于哈希表。

####  算法

算法主要是由头文件<algorithm><functional><numeric>组成

* <algorithm>是所有stl头文件中最大的一个，涉及比较，交换，查找，遍历，复制，修改等操作
* <numeric>体积很小，只包括几个在序列上进行简单数学运算的模板函数
* <functional>定义了一些类模板，用以声明函数对象

以下主要参考[c++---STL常用算法_c++stl的算法_目标成为slam大神的博客-CSDN博客](https://blog.csdn.net/m0_50046535/article/details/124358895)

##### 遍历算法

* for_each 

```c++
//遍历算法，遍历容器元素
//函数原型：for_each（iterator beg，iterator end，_func）；beg开始迭代器end结束迭代器_func函数或者函数对象


//普通函数
void print1(int val)
{
	cout << val << " ";
}
//仿函数
class print2
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};
 
void test01()
{
	vector<int> v;
	v.push_back(2);
	v.push_back(6);
	v.push_back(15);
	v.push_back(8);
	v.push_back(26);
	v.push_back(56);
	v.push_back(16);
	v.push_back(33);
	v.push_back(21);
	for_each(v.begin(), v.end(), print1);//普通函数遍历
	cout << endl;
	for_each(v.begin(), v.end(), print2());//仿函数遍历
}
 
 
int main()
{
	test01();
	system("pause");
	return 0;
}
```

* transform

```c++
//搬运容器到另一个容器中
//函数原型：transform（iterator beg1，iterator end1，iterator beg2，_func）；beg1        源容器开始迭代器end1 源容器结束迭代器beg2 目标容器开始迭代器_func 函数或函数对象


//搬运过程可以做一些逻辑运算
class transform1
{
public:
	int operator()(int val)
	{
		return val;
	}
};
 
void test01()
{
	vector<int> v;
	v.push_back(2);
	v.push_back(6);
	v.push_back(15);
	v.push_back(8);
	v.push_back(26);
	v.push_back(56);
	v.push_back(16);
	v.push_back(33);
	v.push_back(21);
	vector<int> v1;
	v1.resize(v.size());//搬运前给目标容器分配内存
	transform(v.begin(), v.end(), v1.begin(), transform1());
	for_each(v1.begin(), v1.end(), print1);
 
}
 
 
int main()
{
	test01();
	system("pause");
	return 0;
}
```

##### 查找算法

* find

```c++
//查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()
//函数原型：find(iterator beg, iterator end, value);beg 开始迭代器end结束迭代器value查找的元素


//查找内置数据类型
void test01()
{
	vector<int> v;
	v.push_back(2);
	v.push_back(6);
	v.push_back(15);
	v.push_back(8);
	v.push_back(26);
	v.push_back(56);
	v.push_back(16);
	v.push_back(33);
	v.push_back(21);
	vector<int>::iterator it = find(v.begin(), v.end(), 6);
	if (it == v.end())
	{
		cout << "没有找到" << endl;
	}
	else {
		cout << "找到了" << *it << endl;
	}
}
class person
{
public:
	string m_name;
	int m_age;
	person(string name, int age)
	{
		this->m_name = name;
		this->m_age = age;
	}
	//重载==，让底层find知道如何对比person数据类型
	bool operator==(const person&p)
	{
		if (this->m_name == p.m_name && this->m_age == p.m_age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
};
void test02()
{
	vector<person> v1;
	person p1("aaa", 20);
	person p2("bbb", 30);
	v1.push_back(p1);
	v1.push_back(p2);
	vector<person>::iterator it = find(v1.begin(), v1.end(), p2);
	if (it == v1.end())
	{
		cout << "no" << endl;
	}
	else {
		cout << "yes " << it->m_name << " " << (*it).m_age << endl;
	}
}
int main()
{
	test01();
	test02();
	system("pause");
	return 0;
}
```

* find_if

```c++
//按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
//函数原型：find_if(iterator beg, iterator end，_pred); beg开始迭代器end结束迭代器_Pred函数或者谓词（返回bool类型的仿函数)


class greatfive
{
public:
	int operator()(int val)
	{
		return val > 5;
	}
};
//查找内置数据类型
void test01()
{
	vector<int> v;
	v.push_back(2);
	v.push_back(6);
	v.push_back(15);
	v.push_back(8);
	v.push_back(26);
	v.push_back(56);
	v.push_back(16);
	v.push_back(33);
	v.push_back(21);
	vector<int>::iterator it = find_if(v.begin(), v.end(), greatfive());
	if (it == v.end())
	{
		cout << "没有找到" << endl;
	}
	else {
		cout << "找到了" << *it << endl;
	}
}
class person
{
public:
	string m_name;
	int m_age;
	person(string name, int age)
	{
		this->m_name = name;
		this->m_age = age;
	}
	//重载==，让底层find知道如何对比person数据类型
	bool operator==(const person&p)
	{
		if (this->m_name == p.m_name && this->m_age == p.m_age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
};
 
class great20
{
public:
	bool operator()(person &p)
	{
		return p.m_age > 20;
	}
};
void test02()
{
	vector<person> v1;
	person p1("aaa", 20);
	person p2("bbb", 30);
	v1.push_back(p1);
	v1.push_back(p2);
	vector<person>::iterator it = find_if(v1.begin(), v1.end(), great20());
	if (it == v1.end())
	{
		cout << "no" << endl;
	}
	else {
		cout << "yes " << it->m_name << " " << (*it).m_age << endl;
	}
}
 
 
int main()
{
	test01();
	test02();
	system("pause");
	return 0;
}
```

* adjacent_find

```c++
//查找相邻重复元素,返回相邻元素的第一个位置的迭代器
//函数原型：adjacent_find(iterator beg, iterator end) ;beg开始迭代器end结束迭代器


void test01()
{
	vector<int> v;
	v.push_back(2);
	v.push_back(6);
	v.push_back(15);
	v.push_back(15);
	v.push_back(26);
	v.push_back(56);
	v.push_back(16);
	v.push_back(16);
	v.push_back(56);
	vector<int>::iterator it = adjacent_find(v.begin(), v.end());
	if (it == v.end())
	{
		cout << "没有找到" << endl;
	}
	else {
		cout << "找到了" << *it << endl;
	}
}
int main()
{
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* binary_search

```c++
//查找指定的元素，查到返回true否则false
//函数原型：bool binary_search(iterator beg， iterator end, value);beg开始迭代器end结束迭代器value查找的元素
//注意在无序序列中不可用！如果序列是无序的，则结果未知。也许对也许错


void test01()
{
	set<int> v;
	v.insert(2);
	v.insert(6);
	v.insert(15);
	v.insert(26);
	v.insert(56);
	v.insert(16);
	bool it = binary_search(v.begin(), v.end(),10);
	if (!it)
	{
		cout << "没有找到" << endl;
	}
	else {
		cout << "找到了" << endl;
	}
}
 
int main()
{
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* count

```c++
//统计元素个数
//函数原型：int count(iterator beg,iterator end, value);beg 开始迭代器end结束迭代器value 统计的元素
//注意在统计自定义数据类型时，要重载==号才可以进行对比，且在传参数的时候要用const类型的数据类型


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	int num = count(v.begin(), v.end(),14);
	cout << num << endl;
}
class person
{
public:
	string m_name;
	int m_age;
	person(string name, int age)
	{
		this->m_name = name;
		this->m_age = age;
	}
	//重载==，让底层find知道如何对比person数据类型
	bool operator==(const person&p)
	{
		if (this->m_age == p.m_age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
};
 
void test02()
{
	vector<person> v1;
	person p1("aaa", 20);
	person p2("bbb", 30);
	person p3("aaa", 20);
	person p4("aaa", 20);
	person p5("aaa", 60);
	person p6("ccc", 50);
	v1.push_back(p1);
	v1.push_back(p2);
	v1.push_back(p3);
	v1.push_back(p4);
	v1.push_back(p5);
	v1.push_back(p6);
	person p("cc", 20);
	int num = count(v1.begin(), v1.end(), p);
	cout << num << endl;
}
 
 
int main()
{
	test01();
	test02();
	system("pause");
	return 0;
}
```

* count_if

```c++
//按条件统计元素个数
//函数原型：int count_if(iterator beg，iterator end，_Pred);beg开始迭代器end结束迭代器_Pred谓词


class greatfive
{
public:
	int operator()(int val)
	{
		return val > 20;
	}
};
//查找内置数据类型
void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	int num = count_if(v.begin(), v.end(),greatfive());
	cout << num << endl;
}
class person
{
public:
	string m_name;
	int m_age;
	person(string name, int age)
	{
		this->m_name = name;
		this->m_age = age;
	}
	//重载==，让底层find知道如何对比person数据类型
	bool operator==(const person&p)
	{
		if (this->m_age == p.m_age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
};
 
class great20
{
public:
	bool operator()(person &p)
	{
		return p.m_age > 20;
	}
};
void test02()
{
	vector<person> v1;
	person p1("aaa", 20);
	person p2("bbb", 30);
	person p3("aaa", 20);
	person p4("aaa", 20);
	person p5("aaa", 60);
	person p6("ccc", 50);
	v1.push_back(p1);
	v1.push_back(p2);
	v1.push_back(p3);
	v1.push_back(p4);
	v1.push_back(p5);
	v1.push_back(p6);
	int num = count_if(v1.begin(), v1.end(), great20());
	cout << num << endl;
}
 
 
int main()
{
	test01();
	test02();
	system("pause");
	return 0;
}
```

##### 排序算法

* sort

```c++
//对元素进行排序
//函数原型： sort(iterator beg, iterator end，_Pred);beg开始迭代器end 结束迭代器_Pred 谓词


class compare1
{
public:
	int operator()(int val1,int val2)
	{
		return val1 > val2;
	}
};
//查找内置数据类型
 
void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(),print2());
	cout << endl;
	cout << "---------------------" << endl;
 
	//降序排列
	sort(v.begin(), v.end(),compare1());
	for_each(v.begin(), v.end(), print2());
}
 
int main()
{
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* random_shuffle

```c++
//洗牌: 指定范围内的元素随机调整次序
//函数原型：randomn_shuffle( iterator beg, iterator end);beg开始迭代器end 结束迭代器
//注意在使用前要加一个随机数种子，才能实现每次运行都是随机的状态：srand((unsigned int)time(NULL));


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(),print2());
	cout << endl;
	cout << "---------------------" << endl;
 
	random_shuffle(v.begin(), v.end());
	for_each(v.begin(), v.end(), print2());
}
 
int main()
{
    srand((unsigned int)time(NULL));//随机数种子
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* merge

```c++
//两个容器元素合并，并存储到另一个容器中
//函数原型：merge(iterator beg1，iterator end1，iterator beg2，iterator end2，iterator dest);beg1容器1开始迭代器end1容器1结束迭代器beg2容器2开始迭代器end2客器2结束迭代器dest目标容器开始迭代器
//合并时两个容器必须是有序的，合并之后的序列仍然是有序的！注意在合并之前要给目标容器提前开辟空间，否则会抛出异常！
//vTarget.resize(v1.size() + v2.size());


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(),print2());
	cout << endl;
	cout << "---------------------" << endl;
 
	vector<int> v2;
	v2.push_back(10);
	v2.push_back(30);
	v2.push_back(150);
	v2.push_back(23);
	v2.push_back(67);
	v2.push_back(153);
	v2.push_back(157);
	v2.push_back(123);
	v2.push_back(562);
	v2.push_back(1235);
	v2.push_back(845);
	v2.push_back(777);
	sort(v2.begin(), v2.end());
	for_each(v2.begin(), v2.end(), print2());
 
	cout << endl;
	cout << "---------------------" << endl;
 
	vector<int> v3;
	v3.resize(v.size()+v2.size());
	merge(v.begin(), v.end(), v2.begin(), v2.end(), v3.begin());
	for_each(v3.begin(), v3.end(), print2());
}
int main()
{
	srand((unsigned int)time(NULL));
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* reverse

```c++
//将容器内元素进行反转
//函数原型：reverse(iterator beg,iterator end);beg 开始迭代器end结束迭代器


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(),print2());
	cout << endl;
	cout << "---------------------" << endl;
	reverse(v.begin(), v.end());
	for_each(v.begin(), v.end(), print2());
}
 
int main()
{
	srand((unsigned int)time(NULL));
	test01();
	//test02();
	system("pause");
	return 0;
}
```

##### 拷贝与替换算法

* copy

```c++
//容器中指定范围的元素拷贝到另一个容器中
//函数原型:copy（iterator beg，iterator end，iterator dest)；beg开始迭代器end结束迭代器dest 目标起始迭代器


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	vector<int> v2;
	v2.resize(v.size());
	copy(v.begin(), v.end(), v2.begin());
	for_each(v2.begin(), v2.end(), print2());
 
}
 
int main()
{
	srand((unsigned int)time(NULL));
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* replace

```c++
//将容器内指定范围的旧元素修改为新元素
//函数原型：replace（iterator beg，iterator end，oldvalue，newvalue）beg开始迭代器end结束迭代器old value 旧元素newvalue 新元素


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	replace(v.begin(), v.end(), 14,10000);
	for_each(v.begin(), v.end(), print2());
 
}
 
int main()
{
	//srand((unsigned int)time(NULL));
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* replace_if

```c++
//将区间内满足条件的元素，替换成指定元素
//函数原型：replace_if（iterator beg，iterator end，pred_，newvalue）beg开始迭代器end结束迭代器pred_谓词 （条件）newvalue替换的新元素


class greatfive
{
public:
	int operator()(int val)
	{
		return val > 20;
	}
};
void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	replace_if(v.begin(), v.end(), greatfive(),10000);
	for_each(v.begin(), v.end(), print2());
 
}
int main()
{
	//srand((unsigned int)time(NULL));
	test01();
	//test02();
	system("pause");
	return 0;
}
```

* swap

```c++
//互换两个容器的元素
//函数原型：swap（container c1，container c2） c1 容器1 c2 容器2
//注意一定是同一个类型的容器进行交换，否则会抛出异常！


class print2
{
public:
	void operator()(int val)
	{
		cout << val << " ";
	}
};
void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(50);
	v1.push_back(14);
	v1.push_back(67);
	v1.push_back(153);
	for_each(v1.begin(), v1.end(), print2());
	cout << endl;
	swap(v, v1);
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	for_each(v1.begin(), v1.end(), print2());
}
int main()
{
	//srand((unsigned int)time(NULL));
	test01();
	//test02();
	system("pause");
	return 0;
}
```

##### 算术算法

算术生成算法属于小型算法，使用时包含头文件为#include<numeric>

* accumulate

```c++
//计算容器内元素累计总和
//函数原型：accumulate（iterator beg，iterator end，value）；beg 开始迭代器end 结束迭代器value 起始值


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	int sum = accumulate(v.begin(), v.end(), 0);
	cout << sum << endl;
}
```

* fill

```c++
//向容器中填充元素
//函数原型：fill（iterator beg，iterator end，value）;beg 开始迭代器end 结束迭代器value 填充的值


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	fill(v.begin(), v.end(), 2);
	for_each(v.begin(), v.end(), print2());
}
```

##### 集合算法

* set_intersection

```c++
//求两个集合的交集，返回目标容器的最后一个元素迭代器，两个集合必须是有序的
//函数原型：set_intersection（iterator beg1，iterator end1，iterator beg2，iterator end2，iterator beg3）;beg1，容器1开始迭代器end1，容器1结束迭代器beg2，容器2开始迭代器end2，容器2结束迭代器beg3，交集容器3开始迭代器


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(50);
	v1.push_back(14);
	v1.push_back(67);
	v1.push_back(153);
	v1.push_back(167);
	v1.push_back(15);
	v1.push_back(17);
	v1.push_back(100);
	v1.push_back(101);
	v1.push_back(102);
	sort(v1.begin(), v1.end());
	for_each(v1.begin(), v1.end(), print2());
	cout << endl;
	vector<int> v2;
	v2.resize(min(v.size(),v1.size()));
	vector<int>::iterator it = set_intersection(v.begin(), v.end(), v1.begin(), v1.end(), v2.begin());
	for_each(v2.begin(), it, print2());
	
}
```

* set_union

```c++
//求两个集合的并集，返回目标容器最后一个元素迭代器，两个集合必须是有序序列
//函数原型：set_union（iterator beg1，iterator end1，iterator beg2，iterator end2，iterator beg3）;beg1，容器1开始迭代器end1，容器1结束迭代器beg2，容器2开始迭代器end2，容器2结束迭代器beg3，交集容器3开始迭代器


void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(50);
	v1.push_back(14);
	v1.push_back(67);
	v1.push_back(153);
	v1.push_back(167);
	v1.push_back(15);
	v1.push_back(17);
	v1.push_back(100);
	v1.push_back(101);
	v1.push_back(102);
	sort(v1.begin(), v1.end());
	for_each(v1.begin(), v1.end(), print2());
	cout << endl;
	vector<int> v2;
	v2.resize(v.size()+v1.size());
	vector<int>::iterator it = set_union(v.begin(), v.end(), v1.begin(), v1.end(), v2.begin());
	for_each(v2.begin(), it, print2());
	
}
```

* set_difference

```c++
//求两个集合的差集，返回目标容器最后一个元素迭代器，两个集合必须是有序序列
//函数原型：set_difference(iterator beg1，iterator end1，iterator beg2，iterator end2，iterator beg3);beg1，容器1开始迭代器end1，容器1结束迭代器beg2，容器2开始迭代器end2，容器2结束迭代器beg3，交集容器3开始迭代器
896778080@qq.com
liangchen.wlc@qixingquant.com
void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(50);
	v.push_back(14);
	v.push_back(67);
	v.push_back(153);
	v.push_back(167);
	v.push_back(14);
	v.push_back(26);
	v.push_back(14);
	v.push_back(89); 
	v.push_back(75);
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), print2());
	cout << endl;
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(50);
	v1.push_back(14);
	v1.push_back(67);
	v1.push_back(153);
	v1.push_back(167);
	v1.push_back(15);
	v1.push_back(17);
	v1.push_back(100);
	v1.push_back(101);
	v1.push_back(102);
	sort(v1.begin(), v1.end());
	for_each(v1.begin(), v1.end(), print2());
	cout << endl;
	vector<int> v2;
	v2.resize(v.size()+v1.size());
	vector<int>::iterator it = set_difference(v.begin(), v.end(), v1.begin(), v1.end(), v2.begin());
	for_each(v2.begin(), it, print2());
	
}
```



  

